/*
 * generated by Xtext 2.17.1
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.xtext.services.UpctformaevaluaGrammarAccess;
import upctformaevalua.Assertion;
import upctformaevalua.Evaluation;
import upctformaevalua.EvaluationUnit;
import upctformaevalua.FillingAnswer;
import upctformaevalua.Final;
import upctformaevalua.Hole;
import upctformaevalua.Multiple;
import upctformaevalua.MultipleAnswer;
import upctformaevalua.Paragraph;
import upctformaevalua.Question;
import upctformaevalua.Single;
import upctformaevalua.SingleAnswer;
import upctformaevalua.Training;
import upctformaevalua.TrueOrFalse;
import upctformaevalua.UpctformaevaluaPackage;

@SuppressWarnings("all")
public class UpctformaevaluaSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private UpctformaevaluaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == UpctformaevaluaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case UpctformaevaluaPackage.ASSERTION:
				sequence_Assertion(context, (Assertion) semanticObject); 
				return; 
			case UpctformaevaluaPackage.EVALUATION:
				sequence_Evaluation(context, (Evaluation) semanticObject); 
				return; 
			case UpctformaevaluaPackage.EVALUATION_UNIT:
				sequence_EvaluationUnit_Impl(context, (EvaluationUnit) semanticObject); 
				return; 
			case UpctformaevaluaPackage.FILLING_ANSWER:
				sequence_FillingAnswer(context, (FillingAnswer) semanticObject); 
				return; 
			case UpctformaevaluaPackage.FINAL:
				sequence_Final(context, (Final) semanticObject); 
				return; 
			case UpctformaevaluaPackage.HOLE:
				sequence_Hole(context, (Hole) semanticObject); 
				return; 
			case UpctformaevaluaPackage.MULTIPLE:
				sequence_Multiple(context, (Multiple) semanticObject); 
				return; 
			case UpctformaevaluaPackage.MULTIPLE_ANSWER:
				sequence_MultipleAnswer(context, (MultipleAnswer) semanticObject); 
				return; 
			case UpctformaevaluaPackage.PARAGRAPH:
				sequence_Paragraph(context, (Paragraph) semanticObject); 
				return; 
			case UpctformaevaluaPackage.QUESTION:
				sequence_Question_Impl(context, (Question) semanticObject); 
				return; 
			case UpctformaevaluaPackage.SINGLE:
				sequence_Single(context, (Single) semanticObject); 
				return; 
			case UpctformaevaluaPackage.SINGLE_ANSWER:
				sequence_SingleAnswer(context, (SingleAnswer) semanticObject); 
				return; 
			case UpctformaevaluaPackage.TRAINING:
				sequence_Training(context, (Training) semanticObject); 
				return; 
			case UpctformaevaluaPackage.TRUE_OR_FALSE:
				sequence_TrueOrFalse(context, (TrueOrFalse) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Assertion returns Assertion
	 *
	 * Constraint:
	 *     (text=EString? value=EBoolean?)
	 */
	protected void sequence_Assertion(ISerializationContext context, Assertion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvaluationUnit returns EvaluationUnit
	 *     EvaluationUnit_Impl returns EvaluationUnit
	 *
	 * Constraint:
	 *     (name=EString language=EvaluationLanguageType numberquestions=EInt? (questions+=Question questions+=Question*)?)
	 */
	protected void sequence_EvaluationUnit_Impl(ISerializationContext context, EvaluationUnit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Evaluation returns Evaluation
	 *
	 * Constraint:
	 *     (name=EString name=QualifiedName? (units+=EvaluationUnit units+=EvaluationUnit*)?)
	 */
	protected void sequence_Evaluation(ISerializationContext context, Evaluation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns FillingAnswer
	 *     FillingAnswer returns FillingAnswer
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString? (holes+=Hole holes+=Hole*)?)
	 */
	protected void sequence_FillingAnswer(ISerializationContext context, FillingAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvaluationUnit returns Final
	 *     Final returns Final
	 *
	 * Constraint:
	 *     (name=EString language=EvaluationLanguageType numberquestions=EInt? (questions+=Question questions+=Question*)?)
	 */
	protected void sequence_Final(ISerializationContext context, Final semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Hole returns Hole
	 *
	 * Constraint:
	 *     (text=EString? type=TypeHole?)
	 */
	protected void sequence_Hole(ISerializationContext context, Hole semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns MultipleAnswer
	 *     MultipleAnswer returns MultipleAnswer
	 *
	 * Constraint:
	 *     (statements=Paragraph (answers+=Multiple answers+=Multiple*)? correctfeedback=EString? incorrectfeedback=EString?)
	 */
	protected void sequence_MultipleAnswer(ISerializationContext context, MultipleAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiple returns Multiple
	 *
	 * Constraint:
	 *     (text=EString? value=EBoolean?)
	 */
	protected void sequence_Multiple(ISerializationContext context, Multiple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Paragraph returns Paragraph
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Paragraph(ISerializationContext context, Paragraph semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns Question
	 *     Question_Impl returns Question
	 *
	 * Constraint:
	 *     (correctfeedback=EString? incorrectfeedback=EString?)
	 */
	protected void sequence_Question_Impl(ISerializationContext context, Question semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns SingleAnswer
	 *     SingleAnswer returns SingleAnswer
	 *
	 * Constraint:
	 *     (statements=Paragraph (answers+=Single answers+=Single*)? correctanswer=EInt? correctfeedback=EString? incorrectfeedback=EString?)
	 */
	protected void sequence_SingleAnswer(ISerializationContext context, SingleAnswer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Single returns Single
	 *
	 * Constraint:
	 *     text=EString?
	 */
	protected void sequence_Single(ISerializationContext context, Single semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EvaluationUnit returns Training
	 *     Training returns Training
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         language=EvaluationLanguageType 
	 *         numberquestions=EInt? 
	 *         Attempts=EInt? 
	 *         grade=TypeGrade? 
	 *         (questions+=Question questions+=Question*)?
	 *     )
	 */
	protected void sequence_Training(ISerializationContext context, Training semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Question returns TrueOrFalse
	 *     TrueOrFalse returns TrueOrFalse
	 *
	 * Constraint:
	 *     ((assertions+=Assertion assertions+=Assertion*)? correctfeedback=EString? incorrectfeedback=EString?)
	 */
	protected void sequence_TrueOrFalse(ISerializationContext context, TrueOrFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
